---
layout: post
title: "SICP exercises 1.9 - 1.10"
category: SICP - wizard book
tags: [ SICP solutions, done-and-done ]
---
{% include JB/setup %}
<h4 id="exercise-1.9">Exercise 1.9</h4>
<p>Each of the following two procedures defines a method for adding two positive integers in terms of the procedures <code>inc</code>, which increments its argument by 1, and <code>dec</code>, which decrements its argument by 1.</p>
<pre><code>(define (+ a b))
  (if (= a 0))
      b
      (inc (+ (dec a) b))))

(define (+ a b))
  (if (= a 0))
      b
      (+ (dec a) (inc b))))
</code></pre>
<p>Using the substitution model. illustrate the process generated by each procedure in evaluating <code>(+ 4 5)</code>. Are these processes iterative or recursive?</p>
<h4 id="answer">Answer</h4>
<p>Using the substitution model, first procedure:</p>
<pre><code>(+ 4 5)
(inc (+ 3 5))
(inc (inc (+ 2 5)))
(inc (inc (inc (+ 1 5))))
(inc (inc (inc (inc (+ 0 5)))))
(inc (inc (inc (inc 5))))
(inc (inc (inc 6)))
(inc (inc 7))
(inc 8)
=&gt; 9
</code></pre>
<p>The process that this procedure yields, is recursive, which we can clearly see from she shape and the fact that it is deferring work.</p>
<p>Second procedure:</p>
<pre><code>(+ 4 5)
(+ 3 6)
(+ 2 7)
(+ 1 8)
(+ 0 9)
=&gt; 9
</code></pre>
<p>This process is iterative, it is doing the increment and decrement on the parameters immediately before re-calling +, so there is no deferring of work.</p>
<p>These processes are both linear, linear recursive and linear iterative. That means that the time complexity is proportional to n, O(n). The space needed by these processes, is linear in the first case, since it needs to store future operations on a stack proportional to n. The second procedure however needs only a constant amount of space regardless of the size of n, since it does not need to store information about deferred work.</p>
<h4 id="exercise-1.10">Exercise 1.10</h4>
<p>The following procedure conputes a mathematical function called Ackermann's function.</p>
<pre><code>(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1)
                 (A x (- y 1))))))
</code></pre>
<p>What are the values of the following expressions?</p>
<p><code>(A 1 10)</code></p>
<p><code>(A 2 4)</code></p>
<p><code>(A 3 3)</code></p>
<p>Consider the following procedures, where <code>A</code> is the procedure defined above:</p>
<p><code>(define (f n) (A 0 n))</code></p>
<p><code>(define (g n) (A 1 n))</code></p>
<p><code>(define (h n) (A 2 n))</code></p>
<p><code>(define (k n) (* 5 n n))</code></p>
<p>Give concise mathematical definitions for the functions computed by the procedures <code>f</code>, <code>g</code> and <code>h</code> for positive integer values of n. For example, <code>(k n)</code> computes <img src="http://chart.apis.google.com/chart?cht=tx&amp;chl=5n%5E%7B2%7D" alt="5n^{2}" title="5n^{2}" />.</p>
<h4 id="answer-1">Answer</h4>
<p>The values of the expressions are:</p>
<p><code>1024</code></p>
<p><code>65536</code></p>
<p><code>65536</code></p>
<p>I did the first using the substitution model, and could see that this function is deeply recursive, and uses a lot of steps to complete. It also produces values that grow extremely fast when <em>x</em> is larger than 1. For example <code>(A 2 4)</code> is 65536 and <code>(A 2 5)</code> produces a number with 19730 digits!</p>
<p>Let's start by looking at a formal definition for the Ackermann function <code>A</code> which <code>f</code> <code>g</code> and <code>h</code> calls internally:</p>
<p><br /><img src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%0A%5C%5B%20A%28x%2C%20y%29%20%3D%20%5Cleft%5C%7B%20%5Cbegin%7Barray%7D%7Bll%7D%0A0%20%26%20%5Cmbox%7Bif%20%24y%3D0%24%7D%5C%5C%0A2y%20%26%20%5Cmbox%7Bif%20%24x%3D0%24%7D%5C%5C%0A2%20%26%20%5Cmbox%7Bif%20%24y%3D1%24%7D%5C%5C%0AA%28x-1%2C%20A%28x%2C%20y-1%29%29%5Cend%7Barray%7D%20%5Cright.%20%5C%5D%0A" alt="
\[ A(x, y) = \left\{ \begin{array}{ll}
0 &amp; \mbox{if $y=0$}\\
2y &amp; \mbox{if $x=0$}\\
2 &amp; \mbox{if $y=1$}\\
A(x-1, A(x, y-1))\end{array} \right. \]
" title="
\[ A(x, y) = \left\{ \begin{array}{ll}
0 &amp; \mbox{if $y=0$}\\
2y &amp; \mbox{if $x=0$}\\
2 &amp; \mbox{if $y=1$}\\
A(x-1, A(x, y-1))\end{array} \right. \]
" /><br /></p>
<p>What we want to do here is re-write this two variable function as one variable functions, using fixed values for x.</p>
<p>Since <code>f</code> calls <code>A</code> with the fixed value zero for x, it will always hit the second base case x=0 in the definition above, so the definition for <code>f</code> is simply:</p>
<p><br /><img src="http://chart.apis.google.com/chart?cht=tx&amp;chl=f%28n%29%3D2n" alt="f(n)=2n" title="f(n)=2n" /><br /></p>
<p>For <code>g</code> <code>A</code> will be called with the fixed value of 1 for x. Since the recursive call of the Ackermann function will be with x-1, and then hit the base case of x=0, we can use the f(n) function in place of the recursive x-1 call, and make a recursive definition for <code>g(n)</code> in terms of <code>f(n)</code>. Also re-using <code>f(n)</code> for the base cases.</p>
<p><br /><img src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%0A%5C%5B%20g%28n%29%20%3D%20%5Cleft%5C%7B%20%5Cbegin%7Barray%7D%7Bll%7D%0Af%28n%29%20%26%20%5Cmbox%7Bif%20%24n%3C2%24%7D%5C%5C%0Af%28g%28n-1%29%29%5Cend%7Barray%7D%20%5Cright.%20%5C%5D%0A" alt="
\[ g(n) = \left\{ \begin{array}{ll}
f(n) &amp; \mbox{if $n&lt;2$}\\
f(g(n-1))\end{array} \right. \]
" title="
\[ g(n) = \left\{ \begin{array}{ll}
f(n) &amp; \mbox{if $n&lt;2$}\\
f(g(n-1))\end{array} \right. \]
" /><br /></p>
<p>Example:</p>
<pre><code>g(4)
f(g(3))
f(f(g(2)))
f(f(f(g(1))))
f(f(f(2)))
f(f(4))
f(8)
=&gt; 16
</code></pre>
<p>Since the base case of <code>g(n)</code> is two, and <code>f(n)</code> multiplies n by two, this procedure will reach its base case 2, and then recursively call <code>f(n)</code> (multiply by two) n times on the result. So what it really computes is 2 to the power of n, so the definition is:</p>
<p><br /><img src="http://chart.apis.google.com/chart?cht=tx&amp;chl=g%28n%29%3D2%5E%7Bn%7D" alt="g(n)=2^{n}" title="g(n)=2^{n}" /><br /></p>
<p>Similarly we can then make a recursive definition of h(n) in terms of g(n):</p>
<p><br /><img src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%0A%5C%5B%20h%28n%29%20%3D%20%5Cleft%5C%7B%20%5Cbegin%7Barray%7D%7Bll%7D%0Af%28n%29%20%26%20%5Cmbox%7Bif%20%24n%3C2%24%7D%5C%5C%0Ag%28h%28n-1%29%29%5Cend%7Barray%7D%20%5Cright.%20%5C%5D%0A" alt="
\[ h(n) = \left\{ \begin{array}{ll}
f(n) &amp; \mbox{if $n&lt;2$}\\
g(h(n-1))\end{array} \right. \]
" title="
\[ h(n) = \left\{ \begin{array}{ll}
f(n) &amp; \mbox{if $n&lt;2$}\\
g(h(n-1))\end{array} \right. \]
" /><br /></p>
<p>This reaches it's base case, which is two, then raises 2 to the power of 2. Then raises two to the power of that result, and so forth in a nested exponentiation. It gets a little tricky, an example:</p>
<pre><code>h(4)
g(h(3))
g(g(g(2)))
g(g(g(h(1))))
g(g(g(2))) ; 2 to the power of 2 = 4
g(g(4))    ; 2 to the power of 4 = 16
g(16)      ; 2 to the power of 16 = 65536
</code></pre>
<p>This type of iterated exponential is called <em>tetration</em> and is denoted <img src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5E%7Ba%7Db" alt="^{a}b" title="^{a}b" />, for this example: <br /><img src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5E%7B4%7D2%3D2%5E%7B2%5E%7B2%5E%7B2%7D%7D%7D%3D2%5E%7B2%5E%7B4%7D%7D%3D2%5E%7B16%7D%3D65536" alt="^{4}2=2^{2^{2^{2}}}=2^{2^{4}}=2^{16}=65536" title="^{4}2=2^{2^{2^{2}}}=2^{2^{4}}=2^{16}=65536" /><br /></p>
<p>So the concise mathematical definition for <code>h(n)</code> is:</p>
<p><br /><img src="http://chart.apis.google.com/chart?cht=tx&amp;chl=h%28n%29%3D%5E%7Bn%7D2" alt="h(n)=^{n}2" title="h(n)=^{n}2" /><br /></p>
