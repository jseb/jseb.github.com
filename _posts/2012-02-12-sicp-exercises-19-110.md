---
layout: post
title: "SICP exercises 1.9 - 1.10"
category: SICP - wizard book
tags: [ SICP solutions, done-and-done ]
---
{% include JB/setup %}

#### Exercise 1.9
Each of the following two procedures defines a method for adding two positive
integers in terms of the procedures `inc`, which increments its argument by 1,
and `dec`, which decrements its argument by 1.

    (define (+ a b))
	  (if (= a 0))
	      b
          (inc (+ (dec a) b))))

	(define (+ a b))
	  (if (= a 0))
          b
          (+ (dec a) (inc b))))

Using the substitution model, illustrate the process generated by each procedure
in evaluating `(+ 4 5)`. Are these processes iterative or recursive?

#### Answer
Using the substitution model, first procedure:

	(+ 4 5)
	(inc (+ 3 5))
	(inc (inc (+ 2 5)))
	(inc (inc (inc (+ 1 5))))
	(inc (inc (inc (inc (+ 0 5)))))
	(inc (inc (inc (inc 5))))
	(inc (inc (inc 6)))
	(inc (inc 7))
	(inc 8)
	=> 9

The process that this procedure yields, is recursive, which we can clearly see
from the shape and the fact that it is deferring work.

Second procedure:

	(+ 4 5)
	(+ 3 6)
	(+ 2 7)
	(+ 1 8)
	(+ 0 9)
	=> 9

This process is iterative, it is doing the increment and decrement on the
parameters immediately before re-calling +, so there is no deferring of work.

These processes are both linear, linear recursive and linear iterative. That
means that the time complexity is proportional to n, O(n). The space needed by
these processes, is linear in the first case, since it needs to store future
operations on a stack proportional to n. The second procedure however needs only
a constant amount of space regardless of the size of n, since it does not need
to store information about deferred work.

#### Exercise 1.10
The following procedure computes a mathematical function called Ackermann's
function.

	(define (A x y)
	  (cond ((= y 0) 0)
            ((= x 0) (* 2 y))
            ((= y 1) 2)
            (else (A (- x 1)
                      (A x (- y 1))))))

What are the values of the following expressions?

`(A 1 10)`

`(A 2 4)`

`(A 3 3)`

Consider the following procedures, where `A` is the procedure defined above:

`(define (f n) (A 0 n))`

`(define (g n) (A 1 n))`

`(define (h n) (A 2 n))`

`(define (k n) (* 5 n n))`

Give concise mathematical definitions for the functions computed by the
procedures `f`, `g` and `h` for positive integer values of n. For example,
`(k n)` computes $5n^{2}$.

#### Answer
The values of the expressions are:

`1024`

`65536`

`65536`

I did the first using the substitution model, and could see that this function
is deeply recursive, and uses a lot of steps to complete. It also produces
values that grow extremely fast when *x* is larger than 1. For example `(A 2 4)`
is 65536 and `(A 2 5)` produces a number with 19730 digits!


Let's start by looking at a formal definition for the Ackermann function `A`
which `f` `g` and `h` calls internally:

$$
A(x, y) = \left\{ \begin{array}{ll}
0 & \mbox{if $y=0$}\\
2y & \mbox{if $x=0$}\\
2 & \mbox{if $y=1$}\\
A(x-1, A(x, y-1))\end{array} \right.
$$

What we want to do here is re-write this two variable function as one variable
functions, using fixed values for *x*.

Since `f` calls `A` with the fixed value zero for *x*, it will always hit the
second base case *x=0* in the definition above, so the definition for `f` is
simply:

$$ f(n)=2n $$

For `g` `A` will be called with the fixed value of 1 for *x*. Since the
recursive call of the Ackermann function will be with *x-1*, and then hit the
base case of *x=0*, we can use `f(n)` in place of the recursive *x-1* call, and
make a recursive definition for `g(n)` in terms of `f(n)`. Also re-using `f(n)`
for the base cases.

$$
g(n) = \left\{ \begin{array}{ll}
f(n) & \mbox{if $n<2$}\\
f(g(n-1))\end{array} \right.
$$

Example:

	g(4)
	f(g(3))
	f(f(g(2)))
	f(f(f(g(1))))
	f(f(f(2)))
	f(f(4))
	f(8)
	=> 16

Since the base case of `g(n)` is two, and `f(n)` multiplies *n* by two, this
procedure will reach its base case 2, and then recursively call `f(n)` (multiply
by two) *n* times on the result. So what it really computes is 2 to the power of
*n*, so the definition is:

$$ g(n)=2^{n} $$

In the same way, we can then make a recursive definition of `h(n)` in terms of
`g(n)`:

$$
h(n) = \left\{ \begin{array}{ll}
f(n) & \mbox{if $n<2$}\\
g(h(n-1))\end{array} \right.
$$

This reaches it's base case, which is two, then raises 2 to the power of 2. Then
raises two to the power of that result, and so forth in a nested exponentiation.
It gets a little tricky, an example:

	h(4)
	g(h(3))
	g(g(g(2)))
	g(g(g(h(1))))
	g(g(g(2))) ; 2 to the power of 2 = 4
	g(g(4))    ; 2 to the power of 4 = 16
	g(16)	   ; 2 to the power of 16 = 65536

This type of iterated exponential is called *tetration* and is denoted
$$ ^{a}b $$, for this example:
$$^{4}2=2^{2^{2^{2}}}=2^{2^{4}}=2^{16}=65536$$

So the concise mathematical definition for `h(n)` is:

$$h(n)=^{n}2$$
